# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/data.declarative.ipynb (unless otherwise specified).

__all__ = ['schema_init', 'SchemaFactory', 'load_schema_folder', 'register_schema_folder']

# Cell
# hide
import json
import re
import os
import requests
import urllib
import pathlib

from .itembase import Item

# Cell
# hide
_generated_schema: dict[str, type] = dict()

def schema_init(self, **kwargs):
    super(type(self), self).__init__(**kwargs)

    for p in self._property_kwargs:
        setattr(self, p, kwargs.get(p, None))

    for e in self._edge_kwargs:
        setattr(self, e, kwargs.get(e, list()))

class SchemaFactory:

    @staticmethod
    def is_valid_schema_name(name: str) -> bool:
        """Check if name is a valid schema name"""
        return re.match(r"[A-Z][a-zA-Z0-9_]*", name)

    @staticmethod
    def create_schema(name: str, properties: list, edges: list,
                      base: type=Item, description=None) -> type:
        """
        Create a type for schema from a name, list of properties and list of edges. Optionally set the base schema.
        """
        if not  SchemaFactory.is_valid_schema_name(name):
            raise ValueError(f"{name} is not a valid schema name.")

        properties = [p for p in properties if p not in base.properties]
        edges = [e for e in edges if e not in base.edges]

        # Store property_kwargs and edge_kwargs of self to set these in the init.
        cls_dict = {
            "_property_kwargs": properties,
            "_edge_kwargs": edges,
            "properties": base.properties + properties,
            "edges": base.edges + edges,
            "description": description,
            "__init__": schema_init
        }

        schema_cls = type(
            name,
            (base,),
            cls_dict
        )
        return schema_cls

    @staticmethod
    def from_dict(name: str, schema_dict: dict) -> type:
        """
        Creates a schema type from a dictionary. See https://gitlab.memri.io/memri/schema/ for format.

        TODO add edge constraints ("sequenced" and "singular")
        TODO add option for different base class
        """
        properties = schema_dict.get("properties", [])
        edges = list(schema_dict.get("relations", {}).keys())
        description=schema_dict.get("description", None)

        return SchemaFactory.create_schema(
            name=name,
            properties=properties,
            edges=edges,
            description=description
        )

    @staticmethod
    def from_file(file_name: str) -> type:
        """
        Create a schema class from json file.
        """
        schema_name = os.path.splitext(os.path.basename(file_name))[0]
        with open(file_name, "r") as f:
            schema_dict = json.load(f)
        return SchemaFactory.from_dict(schema_name, schema_dict)

    @staticmethod
    def from_url(url: str) -> type:
        """
        Create a schema class from json url.
        """
        file_name = urllib.parse.urlparse(url)[2].rpartition('/')[-1]
        schema_name = os.path.splitext(file_name)[0]
        schema_dict = requests.get(url).json()
        return SchemaFactory.from_dict(schema_name, schema_dict)

# Cell
# hide

def load_schema_folder(path: str) -> dict[str, type]:
    """
    Add a folder of json files to generated schema
    """
    generated_schema = dict()

    file_names = pathlib.Path(path).glob(f"*.json")
    for file_name in file_names:
        s = SchemaFactory.from_file(file_name)
        generated_schema[s.__name__] = s

    return generated_schema

def register_schema_folder(path: str, overwrite_existing=True) -> None:
    """
    Load schema from folder and add to globals()
    """

    for k, v in load_schema_folder(path).items():
        if k in globals() and not overwrite_existing:
            print(f"Skipping schema {k}: schema already exists.")
        else:
            globals()[k] = v
            print(globals()[k])

            import globals()[k]
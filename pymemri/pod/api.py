# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/pod.api.ipynb (unless otherwise specified).

__all__ = ['DEFAULT_POD_ADDRESS', 'POD_VERSION', 'PodError', 'PodAPI']

# Cell
import os
from typing import Any, Dict, List, Generator
import requests

# Cell
DEFAULT_POD_ADDRESS = os.environ.get("POD_ADDRESS") or "http://localhost:3030"
POD_VERSION = "v4"

# Cell
class PodError(Exception):
    def __init__(self, *args: List[Any]) -> None:
        super().__init__(*args)

    def __str__(self) -> str:
        return " ".join([str(a) for a in self.args if a])

# Cell
class PodAPI:
    def __init__(
        self,
        database_key: str,
        owner_key: str,
        url: str = DEFAULT_POD_ADDRESS,
        version: str = POD_VERSION,
        auth_json: dict = None,
    ) -> None:
        self.database_key = database_key
        self.owner_key = owner_key
        self._url = url
        self.base_url = f"{url}/{version}/{self.owner_key}"
        self.auth_json = self._create_auth(auth_json)

    def _create_auth(self, auth_json: dict = None) -> dict:
        if auth_json is not None:
            return {"type": "PluginAuth", **auth_json}
        else:
            return {"type": "ClientAuth", "databaseKey": self.database_key}

    @property
    def version(self) -> dict:
        response = requests.get(f"{self._url}/version")
        if response.status_code != 200:
            raise PodError(response.status_code, response.text)
        return response.json()

    def post(self, endpoint: str, payload: Any) -> Any:
        body = {"auth": self.auth_json, "payload": payload}
        response = requests.post(f"{self.base_url}/{endpoint}", json=body)
        if response.status_code != 200:
            raise PodError(response.status_code, response.text)
        return response.json()

    def get_item(self, uid: str) -> dict:
        return self.post("get_item", uid)

    def create_item(self, item: dict) -> str:
        return self.post("create_item", item)

    def update_item(self, item: dict) -> None:
        return self.post("update_item", item)

    def get_edges(
        self, uid: str, direction: str = "Outgoing", expand_items: bool = True
    ) -> List[dict]:
        payload = {"item": uid, "direction": direction, "expandItems": expand_items}
        return self.post("get_edges", payload)

    def create_edge(self, src_id: str, tgt_id: str, name: str) -> str:
        payload = {"_source": src_id, "_target": tgt_id, "_name": name}
        return self.post("create_edge", payload)

    def delete_item(self, uid) -> None:
        return self.post("delete_item", uid)

    def search(self, query: dict) -> List[dict]:
        return self.post("search", query)

    def search_paginate(self, query: dict, limit: int = 32) -> Generator:
        if (
            "_limit" in query
            or "dateServerModified" in query
            or "dateServerModified>=" in query
            or "dateServerModified<" in query
        ):
            raise ValueError("Cannot paginate query that contains a date or limit.")
        if "_sortOrder" in query:
            raise NotImplementedError("Only 'Asc' order is supported.")

        query = {**query, "_limit": limit}
        response = self.search(query)
        if not len(response):
            return
            yield

        next_date = 0
        while True:
            query["dateServerModified>="] = next_date
            response = self.search(query)
            if not len(response):
                break

            next_date = response[-1]["dateServerModified"] + 1
            yield response

    def bulk(
        self,
        create_items: List[dict] = None,
        update_items: List[dict] = None,
        create_edges: List[dict] = None,
        delete_items: List[str] = None,
        search: dict = None,
    ) -> Dict[str, list]:

        payload = {
            "createItems": create_items,
            "updateItems": update_items,
            "createEdges": create_edges,
            "deleteItems": delete_items,
            "search": search,
        }
        payload = {k: v for k, v in payload.items() if v is not None}
        return self.post("bulk", payload)
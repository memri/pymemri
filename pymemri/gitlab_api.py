# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/gitlab_api.ipynb (unless otherwise specified).

__all__ = ['MEMRI_PATH', 'MEMRI_GITLAB_BASE_URL', 'ACCESS_TOKEN_PATH', 'GITLAB_API_BASE_URL', 'DEFAULT_PACKAGE_VERSION',
           'TIME_FORMAT_GITLAB', 'PROJET_ID_PATTERN', 'find_git_repo', 'get_registry_api_key', 'upload_in_chunks',
           'IterableToFileAdapter', 'write_file_to_package_registry', 'project_id_from_name',
           'get_project_id_from_project_path_unsafe', 'download_package_file', 'create_repo', 'get_current_username',
           'commit_file', 'rm_tree', 'write_files_to_git', 'create_new_project']

# Cell
from fastprogress.fastprogress import progress_bar
from pathlib import Path
import requests
import os, sys
from getpass import getpass
from datetime import datetime
from git import Repo
import re
from .data.basic import *
from .template.formatter import _plugin_from_template
import urllib

# Cell
MEMRI_PATH = Path.home() / ".memri"
MEMRI_GITLAB_BASE_URL = "https://gitlab.memri.io"
ACCESS_TOKEN_PATH = Path.home() / ".memri/access_token/access_token.txt"
GITLAB_API_BASE_URL = "https://gitlab.memri.io/api/v4"
DEFAULT_PACKAGE_VERSION = "0.0.1"

TIME_FORMAT_GITLAB = '%Y-%m-%dT%H:%M:%S.%fZ'
PROJET_ID_PATTERN = '(?<=<span class="gl-button-text">Project ID: )[0-9]+(?=</span>)'

# Cell
def find_git_repo():
    path = "."
    for i in range(10):
        try:
            repo = Repo(f"{path + ('.' * i)}/")
        except:
            pass
        else:
            break
    if i == 9:
        raise ValueError(f"could not fine git repo in {os.path.abspath('')}")

    repo_name = repo.remotes.origin.url.split('.git')[0].split('/')[-1]
    return repo_name

# Cell
def get_registry_api_key():
    ACCESS_TOKEN_PATH.parent.mkdir(parents=True, exist_ok=True)
    if ACCESS_TOKEN_PATH.is_file():
        with open(ACCESS_TOKEN_PATH, "r") as f:
            return f.read()
    else:
        print(f"""
        The first time you are uploading a model you need to create an access_token
        at https://gitlab.memri.io/-/profile/personal_access_tokens?name=Model+Access+token&scopes=api
        Click at the blue button with 'Create personal access token'"
        """)
        access_token = getpass("Then copy your personal access token from 'Your new personal access token', and paste here: ")
        with open(ACCESS_TOKEN_PATH, "w") as f:
            f.write(access_token)
        return access_token

# Cell
class upload_in_chunks(object):
    def __init__(self, filename, chunksize=1 << 14):
        self.filename = filename
        self.chunksize = chunksize
        self.totalsize = os.path.getsize(filename)
        self.readsofar = 0

    def __iter__(self):
        n = 100
        pb = progress_bar(range(n))
        pb_iter = iter(pb)
        i = 1
        delta = 1 / n
        next(pb_iter, None)

        with open(self.filename, 'rb') as file:
            while True:
                data = file.read(self.chunksize)
                if not data:
                    sys.stderr.write("\n")
                    break
                self.readsofar += len(data)
                percent = self.readsofar * 1e2 / self.totalsize
                while (percent / 100) > i * delta:
                    next(pb_iter, None)
                    i += 1
                yield data
        pb.update_bar(n)

    def __len__(self):
        return self.totalsize

class IterableToFileAdapter(object):
    def __init__(self, iterable):
        self.iterator = iter(iterable)
        self.length = len(iterable)

    def read(self, size=-1): # TBD: add buffer for `len(data) > size` case
        return next(self.iterator, b'')

    def __len__(self):
        return self.length

# Cell
def write_file_to_package_registry(project_id, file_path, api_key, package_name, version=DEFAULT_PACKAGE_VERSION):
    file_path = Path(file_path)
    file_name = file_path.name

    url = f"{GITLAB_API_BASE_URL}/projects/{project_id}/packages/generic/{package_name}/{version}/{file_name}"
    print(f"uploading {file_path}")
    it = upload_in_chunks(file_path)
    res = requests.put(url=url, data=IterableToFileAdapter(it),
                     headers={"PRIVATE-TOKEN": api_key})

    if res.status_code not in [200, 201]:
        print(f"Failed to upload {file_path}: {res.content}")
    else:
        print(f"Succesfully uploaded {file_path}")

# Cell
def project_id_from_name(project_name, api_key, job_token=None):
    if api_key:
        headers = {"PRIVATE-TOKEN": api_key}
    else:
        headers = {"JOB-TOKEN": job_token}
    res = requests.get(f"{GITLAB_API_BASE_URL}/projects",
                       headers=headers,
                       params={
                           "owned": True,
                           "search": project_name
                       })
    # we need this extra filter (search is not exact match)
    res = [x.get("id") for x in res.json() if x.get("path", None) == project_name]
    if len(res) == 0:
        raise ValueError(f"No plugin found with name {project_name}, make sure to enter the name as specified in the url of the repo")
    else:
        return res[0]

# Cell
def get_project_id_from_project_path_unsafe(project_path):
    try:
        res = requests.get(f"{MEMRI_GITLAB_BASE_URL}/{project_path}")
        html = str(res.content)
        match = re.search(PROJET_ID_PATTERN, html)
        return match.group()
    except Exception:
        raise ValueError(f"Could not find project with name {project_path}")

# Cell
def download_package_file(filename, project_path, package_name, out_dir=None,
                          package_version=DEFAULT_PACKAGE_VERSION, download_if_exists=False):

    project_name = str(project_path).split("/")[-1]
    out_dir = out_dir if out_dir is not None else MEMRI_PATH / "projects" / project_name
    out_dir.mkdir(parents=True, exist_ok=True)

    project_id = get_project_id_from_project_path_unsafe(project_path)

    file_path = out_dir / filename
    print(file_path)

    if file_path.exists() and not download_if_exists:
        print(f"{file_path} already exists, and `download_if_exists`==False, using cached version")
        return file_path

    print(f"downloading {filename} from project {project_path}, package {package_name}")

    res = requests.get(
        url=f"{GITLAB_API_BASE_URL}/projects/{project_id}/packages/generic/{package_name}/{package_version}/{filename}"
    )
    res.raise_for_status()
    with open(out_dir / filename, "wb") as f:
        print(f"writing {filename} to {out_dir}")
        f.write(res.content)
    return file_path

# Cell
def create_repo(repo_name):
    url = f"{GITLAB_API_BASE_URL}/projects/"
    api_key = get_registry_api_key()
    payload = {"name": repo_name}
    res = requests.post(url=url, json=payload,
                        headers={"PRIVATE-TOKEN": api_key})
    if res.status_code not in [200, 201]:
        raise ValueError(f"failed to create repo:\n {res.text}")
    print(f"created project {repo_name}")

# Cell
def get_current_username():
    url = f"{GITLAB_API_BASE_URL}/user/"
    api_key = get_registry_api_key()
    res = requests.get(url=url, headers={"PRIVATE-TOKEN": api_key})
    if res.status_code not in [200,201]:
        raise ValueError(f"Could not find current user {res.content}")
    else:
        username = res.json()["username"]
        return username

# Cell
def commit_file(project_name, path_in2out, branch="main"):
    api_key = get_registry_api_key()
    project_id = project_id_from_name(project_name, api_key)
#     file_out_path_escaped = urllib.parse.quote(file_out_path, safe='')

    actions = []

    for file_in_path, file_out_path in path_in2out.items():
        content = read_file(file_in_path)
        action_payload = {"action": "create", "file_path": file_out_path, "content": content}
        actions.append(action_payload)

    url = f"{GITLAB_API_BASE_URL}/projects/{project_id}/repository/commits"
    payload = {"branch": branch, "commit_message": "automated commit", "content": content, "actions": actions}

    res = requests.post(url=url, json=payload,
                        headers={"PRIVATE-TOKEN": api_key})
    files_in = list(path_in2out.keys())
    if res.status_code not in [200, 201, 202]:
        raise ValueError(f"failed to make commit with files {files_in}:\n {res.text}")
    print(f"committed files {files_in}")

#      --data '{"branch": "master", "author_email": "author@example.com", "author_name": "Firstname Lastname",
#                "content": "some content", "commit_message": "create a new file"}' \


# Cell
def rm_tree(pth):
    pth = Path(pth)
    for child in pth.glob('*'):
        if child.is_file():
            child.unlink()
        else:
            rm_tree(child)

    try:
        pth.rmdir()
    except FileNotFoundError as e:
        pass

# Cell
def write_files_to_git(repo, target_dir):
    path_in2out = dict()
    for p in target_dir.rglob("*"):
        if p.is_file():
            path_in_repo = p.relative_to(target_dir)
            path_in2out[str(p)] = str(path_in_repo)
    commit_file(str(repo), path_in2out)


def create_new_project(project_name):
    tmp_dir = Path("/tmp/test") / project_name
    rm_tree(tmp_dir)

    _plugin_from_template(
        template_name="classifier_plugin",
        description="A transformer based sentiment analyis plugin",
        install_requires="transformers,sentencepiece,protobuf,torch==1.10.0",
        target_dir=str(tmp_dir),
        repo_url=f"{MEMRI_GITLAB_BASE_URL}/plugins/{project_name}",
        verbose=False
    )
    write_files_to_git(project_name, tmp_dir)
